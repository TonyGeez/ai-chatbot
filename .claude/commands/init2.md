Analyze the entire codebase systematically and document all critical information about how the application works, its architecture, dependencies, patterns, and potential issues.\n## Analysis Workflow\n### Phase 1: Discovery & Inventory\n1. **Scan the entire directory structure** recursively\n2. Identify all files by type (source code, config, documentation, assets)\n3. Map out the project structure and create a file tree\n4. Identify the tech stack, frameworks, and dependencies\n### Phase 2: Deep Analysis\nExamine and document the following in order:\n#### 2.1 Project Foundation\n- Entry points (main files, index files, server startup)\n- Build configuration (webpack, vite, package.json scripts)\n- Environment variables and configuration files\n- Dependencies and their purposes (both production and dev)\n#### 2.2 Architecture & Structure\n- Overall architecture pattern (MVC, hexagonal, clean architecture, microservices, monolith, etc.)\n- Directory organization and module boundaries\n- Component hierarchy and relationships\n- Data flow patterns\n- Layering strategy (presentation, business logic, data access)\n#### 2.3 Database & Data Layer\n- Database type and version (PostgreSQL, MySQL, MongoDB, etc.)\n- Database schema and table structures\n- Relationships between entities (1-N, N-N, 1-1)\n- ORM/ODM used (Sequelize, TypeORM, Prisma, Mongoose, etc.)\n- Migration strategy and migration files location\n- Database indexes and constraints\n- Data validation at database level\n- Connection pooling configuration\n#### 2.4 Core Functionality\n- Main features and user flows\n- Business logic location and implementation\n- API endpoints and their purposes\n- Data models and domain entities\n- State management approach (Redux, Context API, Vuex, etc.)\n- ACID transaction handling strategies\n- Rollback strategies and data recovery mechanisms\n#### 2.5 Critical Code Patterns\n- Authentication mechanisms (JWT, OAuth, sessions, etc.)\n- Authorization and permission systems (RBAC, ABAC)\n- Error handling strategies\n- Logging and monitoring setup\n- Security implementations (CSRF, XSS, SQL injection prevention, input sanitization)\n- Performance optimization techniques\n- Caching strategies (Redis, in-memory, CDN caching)\n- Background job processing (queues, workers, schedulers)\n- Rate limiting implementations\n- API versioning strategy\n#### 2.6 External Integrations\n- Third-party APIs and services\n- Database connections\n- External libraries usage\n- Webhook implementations (both sending and receiving)\n- Message brokers (RabbitMQ, Kafka, SQS, etc.)\n- Email services and notification systems\n- Payment gateway integrations\n#### 2.7 Dependency & Package Management\n- Dependency injection patterns\n- Package manager used (npm, yarn, pnpm, pip, composer, etc.)\n- Version pinning strategy\n- Monorepo vs polyrepo structure\n- Shared libraries and internal packages\n- Dependency update policies\n#### 2.8 Code Quality Assessment\n- Code duplication instances\n- Complex functions (high cyclomatic complexity)\n- Potential security vulnerabilities\n- Performance bottlenecks\n- Technical debt areas\n- TODO and FIXME comments\n- Test coverage gaps\n### Phase 3: Documentation Generation\nWrite everything to **CCF.md** with the following structure:\n```markdown\n# Complete Codebase Facts (CCF)\n## Executive Summary\n[2-3 paragraph overview of what this application does and how it's built]\n## Tech Stack\n- **Languages**: [List all languages with percentage usage]\n- **Frameworks**: [List all frameworks]\n- **Key Libraries**: [Most important dependencies]\n- **Database**: [Database type, version, and ORM if applicable]\n- **Infrastructure**: [Deployment, hosting, containerization]\n- **Caching**: [Caching solutions used]\n- **Queue Systems**: [Background job processors]\n## Project Structure\n[Complete directory tree with annotations]\n## Architecture Overview\n[Detailed explanation of architectural patterns and design decisions]\n### Architecture Diagram\n[Text-based diagram or description of system components]\n### Architectural Pattern\n[MVC, Hexagonal, Clean Architecture, CQRS, etc. - explain the chosen pattern]\n## Entry Points\n[Document all entry points with file paths and their purposes]\n## Core Modules & Components\n### [Module/Component Name]\n- **Location**: `path/to/file`\n- **Purpose**: [What it does]\n- **Key Functions/Methods**: [List with brief descriptions]\n- **Dependencies**: [What it depends on]\n- **Used By**: [What depends on it]\n[Repeat for each major module]\n## Database Architecture\n### Database Schema\n[Document all tables/collections with fields and types]\n### Entity Relationships\n- **One-to-Many (1-N)**: [List relationships]\n- **Many-to-Many (N-N)**: [List relationships with junction tables]\n- **One-to-One (1-1)**: [List relationships]\n### ORM/ODM Implementation\n- **Tool**: [Name and version]\n- **Configuration**: [Connection settings, pooling]\n- **Models Location**: [Path to model definitions]\n- **Query Patterns**: [Common query patterns used]\n### Migrations\n- **Migration Tool**: [Name of migration system]\n- **Migration Files**: [Location and naming convention]\n- **Migration Strategy**: [How migrations are run and rolled back]\n- **Seeding Strategy**: [How seed data is managed]\n### Database Transactions\n- **ACID Compliance**: [How transactions ensure ACID properties]\n- **Transaction Patterns**: [Where and how transactions are used]\n- **Isolation Levels**: [Transaction isolation configuration]\n- **Rollback Strategies**: [How failed transactions are handled]\n## Data Models & Schema\n[Document all data structures, database tables, API contracts]\n## API Documentation\n### Endpoints\n[List all API endpoints with methods, parameters, and purposes]\n### Rate Limiting\n- **Strategy**: [How rate limiting is implemented]\n- **Limits**: [Request limits per endpoint]\n- **Headers**: [Rate limit headers returned]\n### API Versioning\n[How API versions are managed]\n## Authentication & Authorization\n[Detailed explanation of how auth works]\n### Authentication Methods\n[JWT, sessions, OAuth, etc.]\n### Authorization Strategy\n[RBAC, permissions, middleware]\n### Session Management\n[How sessions are stored and managed]\n## State Management\n[Document state management approach for frontend and backend]\n- **Frontend State**: [Redux, Context API, Vuex, etc.]\n- **Backend State**: [Session management, caching]\n- **Shared State**: [WebSockets, real-time updates]\n## Caching Strategy\n- **Cache Layers**: [Where caching is implemented]\n- **Cache Technology**: [Redis, Memcached, in-memory, etc.]\n- **Cache Invalidation**: [How stale cache is handled]\n- **Cache Keys**: [Naming conventions and patterns]\n## Background Jobs & Queues\n- **Queue System**: [Bull, Sidekiq, Celery, etc.]\n- **Job Types**: [List of background jobs]\n- **Job Scheduling**: [Cron jobs, delayed jobs]\n- **Worker Configuration**: [Number of workers, concurrency]\n- **Failure Handling**: [Retry logic, dead letter queues]\n## Configuration\n[Document all configuration files and environment variables]\n## Build & Deployment\n[Explain build process, deployment pipeline, and environment setup]\n## External Integrations\n[List all third-party services, APIs, and how they're integrated]\n### Webhooks\n- **Incoming Webhooks**: [Services sending webhooks to the app]\n- **Outgoing Webhooks**: [Webhooks the app sends]\n- **Webhook Security**: [Signature verification, authentication]\n## Critical Functions & Algorithms\n[Document complex or business-critical functions with explanations]\n## Security Considerations\n[Document security measures, potential vulnerabilities, and recommendations]\n### Security Implementations\n- **Input Validation**: [How user input is sanitized]\n- **SQL Injection Prevention**: [Parameterized queries, ORM usage]\n- **XSS Prevention**: [Output encoding, CSP headers]\n- **CSRF Protection**: [Token implementation]\n- **Authentication Security**: [Password hashing, token storage]\n- **Authorization Checks**: [Permission verification]\n- **Rate Limiting**: [DDoS protection]\n- **Secrets Management**: [How API keys and secrets are stored]\n## Performance Characteristics\n[Document performance patterns, bottlenecks, and optimizations]\n### Performance Optimizations\n- **Database Indexes**: [Index strategy]\n- **Query Optimization**: [N+1 query prevention]\n- **Caching**: [What is cached and why]\n- **Lazy Loading**: [Where implemented]\n- **Connection Pooling**: [Database connection management]\n## Error Handling & Logging\n[Explain error handling strategy and logging implementation]\n## Testing Strategy\n[Document test coverage, testing approach, and test locations]\n## Code Quality Observations\n### Strengths\n- [List positive patterns and good practices]\n### Areas for Improvement\n- [List technical debt, code smells, and refactoring opportunities]\n### Potential Issues\n- [List bugs, security concerns, or problematic patterns]\n## Dependency Analysis\n[Critical dependencies, versions, and potential upgrade considerations]\n### Dependency Management\n- **Package Manager**: [npm, yarn, etc.]\n- **Dependency Injection**: [How DI is implemented]\n- **Version Strategy**: [Exact vs range versions]\n- **Security Scanning**: [Tools used for vulnerability detection]\n## Transaction Management\n[How database transactions are handled across the application]\n## Rollback Strategies\n[Database rollback, deployment rollback, and data recovery procedures]\n## File Inventory\n[Complete list of files by category with brief descriptions]\n## Key Findings & Recommendations\n[Summary of most important discoveries and suggested actions]\n## Glossary\n[Define project-specific terms, acronyms, and domain concepts]\n```\n## Available Tools Usage\nUse ALL available tools systematically:\n- **File Reading**: Read every relevant source file\n- **Directory Listing**: Map entire project structure\n- **File Search**: Find patterns, imports, and usage\n- **Code Execution**: Run analysis scripts if needed\n- **Pattern Matching**: Search for specific code patterns\n- **Dependency Analysis**: Parse package.json, requirements.txt, composer.json, etc.\n## Analysis Guidelines\n- **Be thorough**: Don't skip files - analyze everything\n- **Be critical**: Identify issues, don't just describe\n- **Be specific**: Include file paths, line numbers, and code examples\n- **Be practical**: Focus on actionable insights\n- **Be clear**: Write for developers who will maintain this code\n- **Be honest**: Document both strengths and weaknesses\n## Output Requirements\n- Write EVERYTHING to a single file: **CCF.md**\n- Use proper Markdown formatting\n- Include code examples in fenced code blocks with language tags\n- Use tables for structured data when appropriate\n- Create a table of contents with anchor links\n- Ensure the document is searchable and well-organized\n## Success Criteria\nYour analysis is complete when:\n- [ ] Every directory has been scanned\n- [ ] All source files have been analyzed\n- [ ] All dependencies are documented\n- [ ] Architecture is clearly explained\n- [ ] Database schema and relationships are mapped\n- [ ] ORM usage and migrations are documented\n- [ ] Authentication and authorization are explained\n- [ ] State management is documented\n- [ ] Security measures are identified\n- [ ] Caching and queue systems are documented\n- [ ] Transaction handling and rollback strategies are explained\n- [ ] Rate limiting and webhooks are documented\n- [ ] Dependency management is analyzed\n- [ ] Critical code patterns are identified\n- [ ] Security and performance concerns are noted\n- [ ] CCF.md is comprehensive and actionable\n- [ ] A developer could understand the entire system from reading CCF.md\n## Important Notes\n- Focus on CRITICAL information - what developers need to know\n- Prioritize security, performance, and maintainability concerns\n- Include actual code snippets as examples\n- Document 'gotchas' and non-obvious behaviors\n- If you find something concerning, explain why it matters\n- Pay special attention to database relationships and data integrity\n- Document all architectural patterns and explain why they were chosen\n- Identify single points of failure and scalability concerns\nBegin your analysis by first scanning the entire directory structure, then proceed methodically through each phase.\n
